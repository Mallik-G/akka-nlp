{"name":"Akka-nlp","tagline":"An integration of the text mining system GATE with Akka","body":"![Dr.Krusche & Partner PartG](https://raw.github.com/skrusche63/spark-elastic/master/images/dr-kruscheundpartner.png)\r\n\r\n## Named Entity Recognition (NER) in Scala\r\n\r\nThis project implements an NER micro service that may be easily integrated in any Akka-based loose coupling environment to bring the power of GATE text processing to distributed data processing systems.\r\n\r\n> Keywords: Akka, ANNIE, GATE, Named Entity Recognition, Scala, Service Oriented Ennvironment, Text Processing\r\n\r\n\r\n[GATE](https://gate.ac.uk/) is a very popular library for text processing, and [Akka](http://akka.io/) is a fascinating toolkit and runtime for building highly concurrent, distributed, and fault tolerant event-driven applications.\r\n\r\n> Why not bring those tools together to build highly concurrent, reactive text engineering applications?\r\n\r\n### ANNIE\r\n\r\nGATE is distributed with an information extraction (IE) system called ANNIE, which is short for A Nearly-New IE system. ANNIE relies on finite state algorithms and the JAPE (Regular Expressions over Annotations) language, and consists of the following components:\r\n\r\n* Unicode Tokenizer,\r\n* Sentence Splitter,\r\n* Part of Speech Tagger,\r\n* Semantic Tagger,\r\n* Gazetteer, and\r\n\r\nmore. All these components may be used to build sophisticated text processing pipelines. It is worth to mention, that the Gazetteer is an easy to use component for (supervised) Named Entity Recognition (NER): \r\n\r\nThe Gazetter requires plain text files, where each text line represents a name, such as a name of a city, organisation or product. These text files are then compiled into finite state machines, prepared for fast reading.\r\n\r\n\r\nIn this project, we wrap GATE to especially get access to ANNIE. The code example below illustrates how to configure and run GATE (or ANNIE) within a Scala application:\r\n```\r\nclass AnnieWrapper(home:String) {\r\n\r\n  Gate.runInSandbox(true);\r\n  Gate.setGateHome(new File(home));\r\n\t   \r\n  Gate.setPluginsHome(new File(home, \"plugins\"))\r\n  Gate.init();\r\n\r\n  val corpus = Factory.newCorpus(\"GATE Corpus\")\r\n  /*\r\n   * This GATE wrapper requires a GATE application installed, e.g. ANNIE  \r\n   */\t   \r\n  val url = new URL(\"file:\" + home + \"/application.xgapp\");\r\n  val application = PersistenceManager.loadObjectFromUrl(url).asInstanceOf[CorpusController]\r\n\r\n  application.setCorpus(corpus)\r\n\r\n```\r\n\r\nA certain text artifact is then processed by GATE with just a few lines of Scala:\r\n```\r\n  def getAnnotations(text:String):Seq[Map[String,String]] = {\r\n\r\n    val document = Factory.newDocument(text)\r\n\tannotateDocument(document) \r\n\r\n\tval annotations = document.getAnnotations()\r\n\tval result = annotations.map(annotation => {\r\n\t     \r\n\t  val features = annotation.getFeatures()\r\n\t  val map = features.map(feature => {\r\n\t       \r\n\t    val k = feature._1.toString\r\n\t    val v = feature._2.toString\r\n\t       \r\n\t    (k,v)\r\n\t       \r\n\t  })\r\n\t     \r\n\t  map.toMap\r\n\t     \r\n\t}).toSeq\r\n\r\n\tFactory.deleteResource(document)\r\n    result\r\n    \r\n  }\r\n\r\n  private def annotateDocument(document:Document):Document = {\r\n\t   \r\n    corpus.add(document)\r\n    application.execute()\r\n      \r\n    corpus.clear()\r\n    document\r\n   \r\n  }\r\n\r\n```\r\n\r\nGATE retrieves a text artifact and returns a sequence of annotations described as a `Seq[Map[String,String]]`, where the map represents a GATE feature map with `feature name -> feature value`.\r\n\r\n### Akka Remoting\r\n\r\nAkka is a toolkit for build concurrent scalable applications, using the [Actor Model](http://en.wikipedia.org/wiki/Actor_model). Akka comes with a feature called *Akka Remoting*, which easily enables to setup a communication between software components in a peer-to-peer fashion.\r\n\r\nAkka and Akka Remoting may therefore be used as an appropriate means to establish a communication between prior independent software components - easy and fast. The figure below illustrates the integration pattern provided with this project.\r\n\r\n![Akka Client-Server Pattern](https://raw.githubusercontent.com/skrusche63/akka-nlp/master/images/Akka%20Client-Server%20Pattern.png)\r\n\r\n#### Server\r\n\r\nThe code shows how an Akka Actor (here `GateMaster`) is configured to build a micro server and get accessible from remote.\r\n```\r\nobject GateService {\r\n\r\n  def main(args: Array[String]) {\r\n    \r\n    val name:String = \"gate-server\"\r\n    val conf:String = \"server.conf\"\r\n\r\n    val server = new GateService(conf, name)\r\n    while (true) {}\r\n    \r\n    server.shutdown\r\n      \r\n  }\r\n\r\n}\r\n\r\nclass GateService(conf:String, name:String) {\r\n\r\n  val system = ActorSystem(name, ConfigFactory.load(conf))\r\n  sys.addShutdownHook(system.shutdown)\r\n\r\n  val master = system.actorOf(Props[GateMaster], name=\"gate-master\")\r\n\r\n  def shutdown = system.shutdown()\r\n  \r\n}\r\n```\r\n\r\nA simple configuration file `server.conf` enable the Actor to support remote access. In this project, the server configuration is specified by a plain text file. In a production environment, such a configuration will be retrieved from an appropriate service registry. \r\n```\r\nakka {\r\n  actor {\r\n    provider = \"akka.remote.RemoteActorRefProvider\"\r\n  }\r\n  remote {\r\n    enabled-transports = [\"akka.remote.netty.tcp\"]\r\n    netty.tcp {\r\n      hostname = \"127.0.0.1\"\r\n      port = 2600\r\n    }\r\n    log-sent-messages = on\r\n    log-received-messages = on\r\n  }\r\n}\r\n```\r\nIf you are interested in more configuration parameter, please have a look [here](http://doc.akka.io/docs/akka/snapshot/general/configuration.html#config-akka-remote).\r\n\r\n#### Master Actor\r\n\r\nThe main building block of the server-side functionality is the Master Actor (here `GateMaster`). It routers requests to a set of Worker Actors ((here `GateWorker`). In this project, a Round Robin routing logic is used.\r\n```\r\nclass GateMaster extends Actor with ActorLogging {\r\n\r\n  /**\r\n   * Construct AnnieWrapper\r\n   */\r\n  val path = \"application.conf\"\r\n  val config = ConfigFactory.load(path)\r\n\r\n  val home = config.getConfig(\"gate\").getString(\"home\")\r\n  val gate = new AnnieWrapper(home)  \r\n  \r\n  val routerCfg = config.getConfig(\"router\")\r\n  \r\n  val retries = routerCfg.getInt(\"retries\")\r\n  val time = routerCfg.getInt(\"time\")\r\n  \r\n  val workers = routerCfg.getInt(\"workers\")\r\n  \r\n  override val supervisorStrategy = OneForOneStrategy(\r\n    maxNrOfRetries=retries,withinTimeRange = DurationInt(time).minutes) {\r\n    case _ : Exception => SupervisorStrategy.Restart\r\n  }\r\n\r\n  val router = context.actorOf(\r\n    Props(new GateWorker(gate)).withRouter(RoundRobinRouter(workers)), name=\"gate-router\")\r\n    \r\n  def receive = {\r\n    \r\n    case req:String => {\r\n\r\n      implicit val ec = context.dispatcher\r\n      implicit val timeout:Timeout = 1.second\r\n\r\n\t  val origin = sender\r\n\r\n\t  val response = ask(router, req).mapTo[Seq[Map[String,String]]]\r\n      response.onSuccess {\r\n        case result => origin ! result       \r\n      }\r\n      response.onFailure {\r\n        case result => origin ! Seq.empty[Map[String,String]]\t      \r\n\t  }\r\n     \r\n    }\r\n    \r\n    case _ => log.info(\"Unknown request\")\r\n  \r\n  }\r\n\r\n}\r\n```\r\n\r\n#### Worker Actor\r\n\r\nFinally, the Worker Actor is implemented to interact with GATE (or ANNIE) to assign annotations to a certain text artifact. The artifact is the request message (here `req`) sent from the Master to the Worker Actor.\r\n```\r\nclass GateWorker(gate:AnnieWrapper) extends Actor with ActorLogging {\r\n\r\n  def receive = {\r\n    \r\n    case req:String => {\r\n      \r\n      sender ! gate.getAnnotations(req)\r\n    \r\n    }\r\n    \r\n    case _ => log.info(\"Unknown request\")\r\n  \r\n  }\r\n\r\n}\r\n```\r\n\r\n#### Client\r\n\r\nTo access the Master Actor from remote, is also just a few lines of Scala code:\r\n```\r\nclass GateClient {\r\n\r\n  private val name = \"gate-client\"\r\n  private val conf = \"client.conf\"\r\n    \r\n  private val url = \"akka.tcp://elastic-server@127.0.0.1:2600/user/gate-master\"\r\n      \r\n  implicit val timeout = Timeout(5.seconds)\r\n    \r\n  private val system = ActorSystem(name, ConfigFactory.load(conf))\r\n  private val remote = system.actorSelection(url)\r\n\r\n  def send(req:Any):Future[Any] = ask(remote, req)    \r\n  def shutdown() = system.shutdown\r\n\r\n}\r\n```\r\nThe client configuration `client.conf` may of course also be retrieved from an appropriate service registry. To be complete, the client-side configuration is given below:\r\n```\r\nakka {\r\n   actor {\r\n     provider = \"akka.remote.RemoteActorRefProvider\"\r\n   }\r\n   remote {\r\n     enabled-transports = [\"akka.remote.netty.tcp\"]\r\n     log-sent-messages = on\r\n     log-received-messages = on\r\n     netty.tcp {\r\n       hostname = \"127.0.0.1\"\r\n       port = 0\r\n     }\r\n   }\r\n}\r\n```\r\n\r\nThe GateClient.scala as well as the associated configuration file is provided with this project for your convenience. Usually, the client is part of a different code base.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}